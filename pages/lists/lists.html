<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-07-13 Wed 00:39 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>List, ArrayList, LinkedList</title>
<meta name="author" content="Babin Ion" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../../imagine.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">List, ArrayList, LinkedList</h1>

<div id="outline-container-orgc6222b7" class="outline-2">
<h2 id="orgc6222b7">ATEN탴IE</h2>
<div class="outline-text-2" id="text-orgc6222b7">
<p>
Informa탵ia de aici este doar ceea ce 칥mi imaginez eu 칥n cap c칙nd m캒 g칙ndesc la acest subiect. <b>E posibil ca 90% din ceea ce am scris mai jos s캒 fie gre탳it.</b> Scopul acestei pagini este de a oferi o prezentare general캒, foarte abstract캒 탳i pe scurt a informa탵iei.
</p>
</div>
</div>

<div id="outline-container-orge114750" class="outline-2">
<h2 id="orge114750">Cio za ArrayList?</h2>
<div class="outline-text-2" id="text-orge114750">
</div>
<div id="outline-container-orgaf79c99" class="outline-3">
<h3 id="orgaf79c99">Implementarea</h3>
<div class="outline-text-3" id="text-orgaf79c99">
<p>
<code>List</code> - este interfa탵a. <code>ArrayList</code> 탳i <code>LinkedList</code> o implementeaz캒 (<code>implements</code>).
</p>

<p>
<code>ArrayList</code> - o list캒; un tablou obi탳nuit; acela탳i lucru ca un vector (nu confunda탵i cu clasa <code>Vector</code> din Java. Astea dou캒 sunt <a href="https://stackoverflow.com/questions/1386275/why-is-java-vector-and-stack-class-considered-obsolete-or-deprecated?noredirect=1&amp;lq=1">aproape</a> acelea탳i, doar c캒 listele sunt <i>unsynchronized</i>). Practic, la creare se aloc캒 o bucat캒 de memorie, necesar캒 pentru un num캒r anumit de elemente. Dac캒 se adaug캒 mai multe elemente - o bucat캒 칥nc캒 mai mare se aloc캒, iar elementele din bucata precedent캒 (plin캒) sunt copiate 칥n bucata nou캒. Atunci un element este 탳ters, elementele de dup캒 elementul 탳ters trebuiesc recopiate. Recopierea folose탳te mult캒 memorie.
</p>

<p>
<code>LinkedList</code> - list캒 (dublu)칥nl캒n탵uit캒. La creare nu se aloc캒 memorie. C칙nd se adaug캒 un element nou - se creaz캒 un pointer care 칥l leag캒 de elementul precedent 탳i de cel urm캒tor. De obicei, asta va folosi mai mult캒 memorie dec칙t un <code>ArrayList</code>. Atunci c칙nd un element este 탳ters, singurul lucru care se schimb캒 este leg캒tura (pointerul elementului dinaintea celui 탳ters va fi legat de cel de dup캒 cel 탳ters).
</p>
</div>
</div>

<div id="outline-container-orgfa6aed7" class="outline-3">
<h3 id="orgfa6aed7">Ce 탳i c칙nd folosim?</h3>
<div class="outline-text-3" id="text-orgfa6aed7">
<p>
Folosim <code>ArrayList</code> c칙nd vrem s캒 <b>stoc캒m</b> (salv캒m, memor캒m, citim 탳i dup캒 acces캒m etc.) date.
</p>

<p>
Folosim <code>LinkedList</code> c칙nd vrem s캒 <b>manipul캒m</b> datele (ad캒ug캒m, 탳tergem, modific캒m). Keep in mind c캒 aceast캒 regul캒 nu trebuie dus캒 la absurd (nu folosi <code>LinkedList</code> c칙nd ai de 탳ters 3-4 elemente, diferen탵a va fi minimal캒, iar cel mai probabil un <code>ArrayList</code> va fi mai eficient).
</p>
</div>
</div>

<div id="outline-container-org102e26b" class="outline-3">
<h3 id="org102e26b">Array static vs Lista</h3>
<div class="outline-text-3" id="text-org102e26b">
<p>
Dac캒 탳tim dinainte c칙t de mare va fi array-ul dinainte (capacitatea sa maxim캒), folosim un array static (<code>type[] a = new type[n]</code>); (cel pu탵in, a탳a ar spune regula)
</p>

<p>
Dac캒 nu - folosim o list캒 (<code>ArrayList</code>). Cu toate acestea, eu folosesc <code>ArrayList</code> 칥n ambele cazuri, 탳i v캒 recomand s-o face탵i 탳i voi. De ce?
</p>
</div>
<div id="outline-container-orgd555669" class="outline-4">
<h4 id="orgd555669">Item 28: Prefer lists to arrays</h4>
<div class="outline-text-4" id="text-orgd555669">
<p>
Conform <i>Effective Java by Joshua Bloch</i>, cod precum
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98be65;">// </span><span style="color: #98be65;">Va esua la runtime!</span>
<span style="color: #DFDFDF; font-weight: bold;">Long</span>[] <span style="color: #bbc2cf;">objectArray</span> = <span style="color: #DFDFDF; font-weight: bold;">new</span> <span style="color: #DFDFDF; font-weight: bold;">Long</span>[<span style="color: #b4916d; font-weight: bold;">1</span>];
objectArray[<span style="color: #b4916d; font-weight: bold;">0</span>] = <span style="color: #b4916d;">"I don't fit in"</span>; <span style="color: #98be65;">// </span><span style="color: #98be65;">ArrayStoreException: tipul array-ului este Long, dar memoram un String</span>
</pre>
</div>
<p>
este considerat corect (pentru c캒 e탳ueaz캒 abia la runtime). Acest cod, 칥ns캒
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98be65;">// </span><span style="color: #98be65;">Nu se va compila</span>
<span style="color: #DFDFDF; font-weight: bold;">List</span>&lt;<span style="color: #DFDFDF; font-weight: bold;">Long</span>&gt; <span style="color: #bbc2cf;">ll</span> = <span style="color: #DFDFDF; font-weight: bold;">new</span> <span style="color: #DFDFDF; font-weight: bold;">ArrayList</span>&lt;<span style="color: #DFDFDF; font-weight: bold;">Long</span>&gt;(); <span style="color: #98be65;">// </span><span style="color: #98be65;">tipuri incompatibile</span>
ll.add(<span style="color: #b4916d;">"I don't fit in"</span>);
</pre>
</div>
<p>
este considerat gre탳it. Desigur, el este gre탳it 칥n ambele cazuri (nu po탵i pune un <code>String</code> 칥ntr-un container de tip <code>Long</code>), dar cu un array afli despre asta dup캒 ce programul ruleaz캒 (runtime), 칥n timp ce cu un list - la compile time (dup캒 ce programul a fost compilat, deci 칥nainte de a rula).
</p>

<p>
El (Joshua) men탵ioneaz캒 칥nc캒 o diferen탵캒, ce 탵ine de integrarea cu generici, dar nu o includ aici, pentru c캒 칥nc캒 nu 탳tiu prea multe despre ei. Dac캒 voi sunte탵i interesa탵i, citi탵i cartea.
</p>
</div>
</div>
</div>

<div id="outline-container-orge84c962" class="outline-3">
<h3 id="orge84c962">Programare (aproape)func탵ional캒 탳i clasa <code>stream</code></h3>
<div class="outline-text-3" id="text-orge84c962">
</div>
<div id="outline-container-org35ff81e" class="outline-4">
<h4 id="org35ff81e">Func탵iile lambda</h4>
</div>
<div id="outline-container-org76c3701" class="outline-4">
<h4 id="org76c3701">Pu탵in despre programarea func탵ional캒</h4>
<div class="outline-text-4" id="text-org76c3701">
<p>
칉n limbajele de programare func탵ional캒, instrumentul de baz캒 este (<i>a탵i ghicit</i>) func탵ia. 칉n astfel de limbaje avem func탵ii care primesc func탵ii ca parametru, 탳i returneaz캒 alte func탵ii. Java nu este un limbaj func탵ional, 탳i totu탳i ea (pe l칙ng캒 multe alte limbaje populare ast캒zi) 칥mprumut캒 lucruri din programarea func탵ional캒. Desigur, implementarea lor, sintaxa 탳.a.m.d variaz캒 mult (sunt, p칙n캒 la urm캒, dou캒 paradigme diferite), 칥ns캒 esen탵a r캒m칙ne tot acolo (dac캒 칥탵i 칥ncruntezi privirea, a탳a 칥nc칙t ochii t캒i seam캒n캒 cu cei ai unui asian).
</p>

<p>
Ceea ce ne apropie de programarea func탵ional캒 este <code>stream</code>. Nu 탳tiu prea multe despre ea. Mul탵umesc lui Dumnezeu c캒 exista Intellij, care scrie 80% din cod pentru mine. 탲tiu doar c캒 este a탳a clas캒 sau metod캒 - <code>stream</code>, care face magia.
</p>

<p>
O func탵ie lambda e pur 탳i simplu o func탵ie f캒r캒 nume. S캒 presupunem c캒 avem codul urm캒tor:
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #DFDFDF; font-weight: bold;">public</span> <span style="color: #DFDFDF; font-weight: bold;">int</span> <span style="color: #DFDFDF; font-weight: bold;">sum</span>(<span style="color: #DFDFDF; font-weight: bold;">int</span> <span style="color: #bbc2cf;">a</span>, <span style="color: #DFDFDF; font-weight: bold;">int</span> <span style="color: #bbc2cf;">b</span>) { <span style="color: #DFDFDF; font-weight: bold;">return</span> a + b; }
<span style="color: #DFDFDF; font-weight: bold;">public</span> <span style="color: #DFDFDF; font-weight: bold;">void</span> <span style="color: #DFDFDF; font-weight: bold;">afiseazaSumaDouaNumere</span>() {
    System.out.println(sum(<span style="color: #b4916d; font-weight: bold;">3</span>, <span style="color: #b4916d; font-weight: bold;">5</span>));
}
</pre>
</div>

<p>
Desigur, nimeni treaz la cap nu scrie astfel de cod (dac캒 vrei s캒 afi탳ezi c칙t e 3 + 5 afi탳ezi c칙t e 3 + 5), dar s캒 ignor캒m acest lucru pentru moment. S캒 presupunem c캒 avem o astfel de func탵ie, care este folosit캒 de o alt캒 func탵ie, 탳i numai o dat캒. <code>sum</code> este folosit캒 doar de metoda <code>afiseazaSumaDouaNumere</code>, 칥n interiorul ei, 탳i nic캒ieri altundeva. Ei bine, am putea face ceva ca:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #DFDFDF; font-weight: bold;">public</span> <span style="color: #DFDFDF; font-weight: bold;">void</span> <span style="color: #DFDFDF; font-weight: bold;">afiseazaSumaDouaNumere</span>() {
    System.out.println((<span style="color: #b4916d; font-weight: bold;">3</span>, <span style="color: #b4916d; font-weight: bold;">5</span>) -&gt; {<span style="color: #DFDFDF; font-weight: bold;">return</span> <span style="color: #b4916d; font-weight: bold;">3</span> + <span style="color: #b4916d; font-weight: bold;">5</span>;}); <span style="color: #98be65;">// </span><span style="color: #98be65;">ia ca parametri doua numere oricare, returneaza suma</span>
}
</pre>
</div>

<p>
Codul de mai sus, chiar dac캒 nu func탵ioneaz캒 din punct de vedere al limbajului, are sens, 탳i exprim캒 ceea ce vrem s캒 facem. Nu e nevoie s캒 define탳ti o func탵ie care face ceva simplu, 탳i pe care oricum o vei folosi o singur캒 dat캒. <b>Programatorii, la fel ca matematicienii, sunt oameni leno탳i.</b> De ce s캒 define탳ti o func탵ie, c칙nd po탵i s캒 nu o define탳ti?
</p>
</div>
</div>

<div id="outline-container-org0c30a6b" class="outline-4">
<h4 id="org0c30a6b">Iteratorii</h4>
<div class="outline-text-4" id="text-org0c30a6b">
<p>
Este destul de greu de explicat ce sunt iteratorii cu cuvinte, a탳a c캒 o s-o fac prin exemple. Ceea ce trebuie s캒 탵ine탵i minte e c캒 fiecare iterator ia ca parametri cel pu탵in 2 lucruri: o func탵ie 탳i o colec탵ie (o list캒), asupra c캒reia s캒 aplice func탵ia. 칉n Java, 칥ns캒, acestea iau un singur lucru (ca parametru, 칥n orice caz), 탳i anume func탵ia. Colec탵ia este specificat캒 deodat캒, atunci c칙nd folosim metoda <code>.stream()</code> pe ea.
</p>
</div>

<ul class="org-ul">
<li><a id="orgcdc5109"></a><code>map</code><br />
<div class="outline-text-5" id="text-orgcdc5109">
<p>
<code>map</code> ia ca parametru o func탵ie, pe care o aplic캒 fiec캒rui element al colec탵iei. Rezultatul iteratorului <code>map</code> este o colec탵ie, 칥n care fiecare element este rezultatul aplic캒rii func탵iei pe elementul colec탵iei. 칉n exemplul de mai jos, vom crea un nou <code>ArrayList</code>, 칥n care fiecare element este elementul respectiv din <code>numere</code> + 1.
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #DFDFDF; font-weight: bold;">ArrayList</span>&lt;<span style="color: #DFDFDF; font-weight: bold;">Integer</span>&gt; <span style="color: #bbc2cf;">numere</span> = <span style="color: #DFDFDF; font-weight: bold;">new</span> <span style="color: #DFDFDF; font-weight: bold;">ArrayList</span>&lt;&gt;(List.of(<span style="color: #b4916d; font-weight: bold;">1</span>,<span style="color: #b4916d; font-weight: bold;">2</span>,<span style="color: #b4916d; font-weight: bold;">5</span>,<span style="color: #b4916d; font-weight: bold;">9</span>,<span style="color: #b4916d; font-weight: bold;">11</span>,<span style="color: #b4916d; font-weight: bold;">4</span>,<span style="color: #b4916d; font-weight: bold;">7</span>,<span style="color: #b4916d; font-weight: bold;">2</span>));

<span style="color: #DFDFDF; font-weight: bold;">ArrayList</span>&lt;<span style="color: #DFDFDF; font-weight: bold;">Integer</span>&gt; <span style="color: #bbc2cf;">numereNou</span> = (<span style="color: #DFDFDF; font-weight: bold;">ArrayList</span>&lt;<span style="color: #DFDFDF; font-weight: bold;">Integer</span>&gt;) numere.stream().map(element -&gt; element = element + <span style="color: #b4916d; font-weight: bold;">1</span>).collect(Collectors.toList());
</pre>
</div>

<p>
Destul de greu de citit, nu-i a탳a? De asta, v캒 recomand ca atunci c칙nd folosi탵i cel pu탵in dou캒 metode ca <code>.numeMetoda()</code> 칥n stream-ul vostru, s캒 le separa탵i pe linii.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #DFDFDF; font-weight: bold;">ArrayList</span>&lt;<span style="color: #DFDFDF; font-weight: bold;">Integer</span>&gt; <span style="color: #bbc2cf;">numereNou</span> =
                (<span style="color: #DFDFDF; font-weight: bold;">ArrayList</span>&lt;<span style="color: #DFDFDF; font-weight: bold;">Integer</span>&gt;) numere.stream()           <span style="color: #98be65;">// </span><span style="color: #98be65;">(1)</span>
                        .map(element -&gt; element = element + <span style="color: #b4916d; font-weight: bold;">1</span>) <span style="color: #98be65;">// </span><span style="color: #98be65;">(2)</span>
                        .collect(Collectors.toList());         <span style="color: #98be65;">// </span><span style="color: #98be65;">(3)</span>
</pre>
</div>

<p>
탲i acum, hai s캒 analiz캒m pe linii.
</p>
<ol class="org-ol">
<li><code>(ArrayList&lt;Integer&gt;)</code> - asta se nume탳te <i>cast</i>, 탳i reprezint캒 o transformare, dintr-un tip 칥n altul. E nevoie s캒 <i>cast</i>-uim, pentru c캒 칥n linia 3, metoda <code>.collect(Collectors.toList())</code> nu specifica tipul listei.
<code>numere.stream()</code> - sintaxa de folosire. Asta e ceea ce transform캒 obiectul nostru 칥ntr-un obiect ciotkii 游땙.</li>
<li><code>.map(element -&gt; element = element + 1)</code> - Apelul func탵iei <code>.map()</code> cu o lambda, care ia un argument 탳i 칥i adaug캒 1. Aceast캒 func탵ie va crea o list캒 nou캒, 칥n care fiecare element este elemenmtul din lista <code>numere</code> + 1. O s캒 accentuez faptul c캒 <code>.map(...)</code> <b>nu modific캒 lista numere, ci creeaz캒 o list캒 nou캒</b>.</li>
<li><code>.collect(Collectors.toList())</code> - ceea ce transform캒 rezultatul aplic캒rii <code>map</code>-ului 칥ntr-o list캒. Nu 탳tiu prea bine cum func탵ioneaz캒, dar presupun c캒 <code>map</code> nu creaz캒 obiectul propriu-zis, ci 칥l p캒streaz캒 칥n memorie, iar <code>.collect()</code> 칥l ia din memorie 탳i 칥l transform캒 칥n valoare.</li>
</ol>


<p>
<a href="../../index.html">칉napoi</a>
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org56156d7" class="outline-4">
<h4 id="org56156d7"><span class="todo TODO">TODO</span> document better</h4>
</div>
<div id="outline-container-org717f71f" class="outline-4">
<h4 id="org717f71f"><span class="todo TODO">TODO</span> add filter, reduce, forEach, sort</h4>
</div>
<div id="outline-container-org9c0f8ac" class="outline-4">
<h4 id="org9c0f8ac"><span class="todo TODO">TODO</span> book references</h4>
</div>
<div id="outline-container-org04b4b4e" class="outline-4">
<h4 id="org04b4b4e"><span class="todo TODO">TODO</span> add video recommandation</h4>
</div>
</div>
</div>
</div>
</body>
</html>
